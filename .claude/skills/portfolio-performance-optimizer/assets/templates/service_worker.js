// Portfolio Performance Optimized Service Worker
// Generated by Portfolio Performance Optimizer

// Import Workbox for advanced caching strategies
importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');

// Configuration
const CACHE_VERSION = 'v1.0.0';
const CACHE_PREFIX = 'portfolio-';
const OFFLINE_URL = '/offline.html';

// Portfolio-specific performance optimizations
const PERFORMANCE_CONFIG = {
  maxAgeImages: 90 * 24 * 60 * 60,  // 3 months
  maxAgeStatic: 365 * 24 * 60 * 60,  // 1 year
  maxAgeAPI: 5 * 60,  // 5 minutes
  maxEntriesImages: 200,
  maxEntriesStatic: 100,
  maxEntriesAPI: 50,
};

// Precaching critical assets
const PRECACHE_ASSETS = [
  '/',
  '/offline.html',
  '/manifest.json',
  '/_next/static/css/app.css',
  '/_next/static/chunks/app.js',
  '/images/profile-photo.webp',
  '/images/hero-banner.webp',
];

// Cache strategies for different resource types
const cacheStrategies = {
  // Static assets - Cache First for instant loading
  static: {
    strategy: 'cacheFirst',
    cacheName: `${CACHE_PREFIX}static-${CACHE_VERSION}`,
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: PERFORMANCE_CONFIG.maxEntriesStatic,
        maxAgeSeconds: PERFORMANCE_CONFIG.maxAgeStatic,
      }),
    ],
  },

  // Images - Cache First with expiration
  images: {
    strategy: 'cacheFirst',
    cacheName: `${CACHE_PREFIX}images-${CACHE_VERSION}`,
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: PERFORMANCE_CONFIG.maxEntriesImages,
        maxAgeSeconds: PERFORMANCE_CONFIG.maxAgeImages,
        purgeOnQuotaError: true,
      }),
    ],
  },

  // API responses - Network First with fallback to cache
  api: {
    strategy: 'networkFirst',
    cacheName: `${CACHE_PREFIX}api-${CACHE_VERSION}`,
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: PERFORMANCE_CONFIG.maxEntriesAPI,
        maxAgeSeconds: PERFORMANCE_CONFIG.maxAgeAPI,
      }),
    ],
  },

  // Pages - Network First for fresh content
  pages: {
    strategy: 'networkFirst',
    cacheName: `${CACHE_PREFIX}pages-${CACHE_VERSION}`,
    networkTimeoutSeconds: 3,
  },

  // External CDNs - Stale While Revalidate
  external: {
    strategy: 'staleWhileRevalidate',
    cacheName: `${CACHE_PREFIX}external-${CACHE_VERSION}`,
    plugins: [
      new workbox.expiration.ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  },
};

// Register cache strategies
workbox.routing.registerRoute(
  /\.(?:js|css|woff|woff2)$/,
  new workbox.strategies.CacheFirst(cacheStrategies.static)
);

workbox.routing.registerRoute(
  /\.(?:png|jpg|jpeg|gif|webp|avif|svg)$/,
  new workbox.strategies.CacheFirst(cacheStrategies.images)
);

workbox.routing.registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new workbox.strategies.NetworkFirst(cacheStrategies.api)
);

workbox.routing.registerRoute(
  ({ request }) => request.mode === 'navigate',
  new workbox.strategies.NetworkFirst(cacheStrategies.pages)
);

workbox.routing.registerRoute(
  ({ url }) => (
    url.origin === 'https://fonts.googleapis.com' ||
    url.origin === 'https://fonts.gstatic.com' ||
    url.origin === 'https://cdn.jsdelivr.net'
  ),
  new workbox.strategies.StaleWhileRevalidate(cacheStrategies.external)
);

// Precaching installation
workbox.precaching.precacheAndRoute(
  PRECACHE_ASSETS.map(asset => ({
    url: asset,
    revision: CACHE_VERSION,
  }))
);

// Install event
self.addEventListener('install', (event) => {
  console.log('ðŸš€ Portfolio SW: Installing...');
  self.skipWaiting();
});

// Activate event
self.addEventListener('activate', (event) => {
  console.log('âœ… Portfolio SW: Activating...');

  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames
          .filter((cacheName) => {
            return cacheName.startsWith(CACHE_PREFIX) &&
                   !cacheName.includes(CACHE_VERSION);
          })
          .map((cacheName) => {
            console.log('ðŸ—‘ï¸ Portfolio SW: Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          })
      );
    })
  );

  self.clients.claim();
});

// Fetch event with portfolio-specific optimizations
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);

  // Portfolio-specific optimizations
  if (url.pathname.includes('/projects/') && url.pathname.match(/\.(jpg|jpeg|png|webp)$/)) {
    // High priority caching for project screenshots
    event.respondWith(cacheProjectImages(request));
  } else if (url.pathname.includes('/api/projects')) {
    // Network first for project data with background sync
    event.respondWith(networkFirstWithSync(request));
  } else if (url.href.includes('github.com/embed')) {
    // Stale while revalidate for GitHub embeds
    event.respondWith(staleWhileRevalidateEmbed(request));
  }
});

// Portfolio-specific caching functions
async function cacheProjectImages(request) {
  const cache = await caches.open(`${CACHE_PREFIX}project-images-${CACHE_VERSION}`);

  try {
    const response = await fetch(request);
    if (response.ok) {
      const clonedResponse = response.clone();
      await cache.put(request, clonedResponse);
    }
    return response;
  } catch (error) {
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}

async function networkFirstWithSync(request) {
  const cache = await caches.open(`${CACHE_PREFIX}api-${CACHE_VERSION}`);

  try {
    const response = await fetch(request);
    if (response.ok) {
      const clonedResponse = response.clone();
      await cache.put(request, clonedResponse);
    }
    return response;
  } catch (error) {
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }

    // Register background sync
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      self.registration.sync.register('portfolio-data-sync');
    }

    throw error;
  }
}

async function staleWhileRevalidateEmbed(request) {
  const cache = await caches.open(`${CACHE_PREFIX}embeds-${CACHE_VERSION}`);
  const cachedResponse = await cache.match(request);

  const fetchPromise = fetch(request).then((response) => {
    if (response.ok) {
      cache.put(request, response.clone());
    }
    return response;
  });

  return cachedResponse || fetchPromise;
}

// Background sync for portfolio data
self.addEventListener('sync', (event) => {
  if (event.tag === 'portfolio-data-sync') {
    event.waitUntil(syncPortfolioData());
  }
});

async function syncPortfolioData() {
  try {
    // Sync portfolio data when back online
    const response = await fetch('/api/portfolio/sync', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });

    if (response.ok) {
      console.log('ðŸ“± Portfolio data synced successfully');
      // Clear cached portfolio data
      await caches.delete(`${CACHE_PREFIX}api-${CACHE_VERSION}`);
    }
  } catch (error) {
    console.error('Portfolio sync failed:', error);
  }
}

// Push notifications (optional)
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : 'New portfolio update available',
    icon: '/images/icon-192x192.png',
    badge: '/images/badge-72x72.png',
    vibrate: [100, 50, 100],
    data: {
      dateOfArrival: Date.now(),
      primaryKey: 1
    }
  };

  event.waitUntil(
    self.registration.showNotification('Portfolio Update', options)
  );
});

// Notification click handler
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  event.waitUntil(
    clients.openWindow('/')
  );
});

// Performance monitoring
self.addEventListener('fetch', (event) => {
  const start = performance.now();

  event.respondWith(
    (async () => {
      try {
        const response = await fetch(event.request);
        const duration = performance.now() - start;

        // Log slow requests
        if (duration > 1000) {
          console.warn(`Slow request detected: ${event.request.url} (${duration.toFixed(2)}ms)`);
        }

        return response;
      } catch (error) {
        const duration = performance.now() - start;
        console.error(`Request failed: ${event.request.url} (${duration.toFixed(2)}ms)`, error);
        throw error;
      }
    })()
  );
});

// Cleanup function
async function cleanupOldCaches() {
  const cacheNames = await caches.keys();
  const currentCacheNames = [
    `${CACHE_PREFIX}static-${CACHE_VERSION}`,
    `${CACHE_PREFIX}images-${CACHE_VERSION}`,
    `${CACHE_PREFIX}api-${CACHE_VERSION}`,
    `${CACHE_PREFIX}pages-${CACHE_VERSION}`,
    `${CACHE_PREFIX}external-${CACHE_VERSION}`,
    `${CACHE_PREFIX}project-images-${CACHE_VERSION}`,
    `${CACHE_PREFIX}embeds-${CACHE_VERSION}`,
  ];

  return Promise.all(
    cacheNames
      .filter(cacheName => !currentCacheNames.includes(cacheName))
      .map(cacheName => caches.delete(cacheName))
  );
}

console.log('ðŸŽ¨ Portfolio Performance Service Worker loaded and ready');